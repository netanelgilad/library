import { Handler } from './match';
import { Func, Limited, Splay, VariantCreator, VariantError } from './precepts';
import { TypeStr } from './util';
/**
 * From a lookup table to a handler record.
 */
export declare type LookupTableToHandler<T extends {}> = {
    [P in keyof T]: () => T[P];
};
/**
 * Strip all non-function options.
 */
declare type EnsureFunc<T> = T extends Func ? T : never;
/**
 * Utility func to create a handler from a lookup table.
 * @param table
 * @returns
 */
export declare function tableToHandler<T extends Record<K, string>, K extends string, Table extends Record<T[K], unknown>>(table: Table): Handler<T, K>;
interface CompleteOptions {
    withFallback?: (input: unknown) => any;
}
export declare type RegisterLookup<T extends Record<K, string>, K extends string> = {
    [P in T[K]]: unknown;
};
/**
 * Given a union and the current state of the handler, calculate the
 * complementary handler (the handler object with the remaining elements).
 */
declare type ComplementaryHandler<T extends Record<K, string>, K extends string, H extends Partial<Handler<T, K>>> = RemainingKeys<T, K, H> extends never ? never : Handler<Extract<T, Record<K, RemainingKeys<T, K, H>>>, K>;
/**
 * Retrieve keys not yet handled.
 */
declare type RemainingKeys<T extends Record<K, string>, K extends string, H extends Partial<Handler<T, K>>> = keyof H extends never ? T[K] : Exclude<T[K], keyof H>;
declare type ComplementaryLookup<T extends Record<K, string>, K extends string, H extends Partial<Handler<T, K>>> = RemainingKeys<T, K, H> extends never ? never : RegisterLookup<Extract<T, Record<K, RemainingKeys<T, K, H>>>, K>;
/**
 * The matcher, a builder-pattern form of `match()`
 *
 * * Create a matcher `matcher(animal)`
 * * Define cases
 *     * `.when('cat', _ => _.name)`
 *     * `.when(Animal.cat, c => c.name)`
 *     * `.when(['cat', Animal.dog], cd => cd.name)`,
 *     * `.when({cat: c => c.name, dog: d => d.name})`
 *     * `.register({cat: 'purr', dog: 'woof'})` for constants.
 *
 * * Execute the matcher
 *     * `.complete()` brings exhaustiveness checking
 *     * `.execute()` immediately runs the matcher, whether or not all cases are handled.
 *     * `.else(_ => {...})` immediately runs the matcher, resolving unhandled cases with a function.
 */
export declare class Matcher<T extends Record<K, string>, K extends string, H extends Partial<Handler<T, K>>> {
    /**
     * The match target.
     */
    readonly target: T;
    /**
     * The discrimant used for the union `T`
     */
    readonly key: K;
    /**
     * The in-progress handler object.
     */
    readonly handler: H;
    /**
     * Create a new matcher from the target
     * @param target the
     * @param handler the initial handler. Use `{}` for standard functionality.
     * @param key the discriminant. Use `'type'` for standard functionality.
     */
    constructor(
    /**
     * The match target.
     */
    target: T, 
    /**
     * The discrimant used for the union `T`
     */
    key: K, 
    /**
     * The in-progress handler object.
     */
    handler: H);
    /**
     * Immediately execute the matcher. Exhaustiveness is not guaranteed.
     *
     * This is a **terminal** and resolves the matcher.
     */
    execute(): RemainingKeys<T, K, H> extends never ? ReturnType<EnsureFunc<H[keyof H]>> : ReturnType<EnsureFunc<H[keyof H]>> | undefined;
    /**
     * Handle all unhandled cases and immediately execute.
     *
     * > **Exhaust** â€” to consume entirely, _Merriam-Webster_
     *
     * This is a **terminal** and resolves the matcher.
     * @param remainingCases an object wiht a method to handle every remaining case.
     * @returns the result of executing the handler, given these final additions.
     */
    exhaust<R extends ComplementaryHandler<T, K, H>>(remainingCases: R): ReturnType<(H & R)[T[K]]>;
    /**
     * Resolve all remaining cases without executing the matcher.
     * @param remainingCases
     * @returns
     */
    remaining<R extends ComplementaryHandler<T, K, H>>(remainingCases: R): Matcher<T, K, H & R>;
    complete: RemainingKeys<T, K, H> extends never ? (options?: CompleteOptions | undefined) => ReturnType<EnsureFunc<H[keyof H]>> : VariantError<["The handler has not been fully completed. Expected key(s)", RemainingKeys<T, K, H>]>;
    /**
     * Execute the match. If the target type has been explicitly handled, use that logic.
     * Otherwise use the function passed here.
     *
     * This is a **terminal** and resolves the matcher.
     * @param func
     * @returns
     */
    else<ElseFunc extends (variant: Exclude<T, Record<K, keyof H>>) => any>(func: ElseFunc): ReturnType<EnsureFunc<H[keyof H]> | ElseFunc>;
    /**
     * Register a series of options as a lookup table.
     *
     * ```ts
     * const getSound = (a: Animal) => matcher(a)
     *     .register({
     *         cat: 'purr',
     *         dog: 'woof',
     *         snake: 'hiss',
     *     })
     *     .complete()
     * ```
     * @param table
     * @returns
     */
    register<Table extends Splay<ComplementaryLookup<T, K, H>>>(table: Limited<Table, T[K]> & Table): Matcher<T, K, H & LookupTableToHandler<Table>>;
    /**
     * Provide an exhaustive table of the unhandled options and look up which value
     * to use based on the instance.
     *
     * This is a **terminal** and resolves the matcher.
     *
     * ```ts
     * const getSound = (a: Animal) => matcher(a)
     *     .lookup({
     *         cat: 'purr',
     *         dog: 'woof',
     *         snake: 'hiss',
     *     })
     * ```
     * @param table
     * @returns
     */
    lookup<Table extends Record<RemainingKeys<T, K, H>, any>>(table: Table): ReturnType<(H & LookupTableToHandler<Table>)[T[K]]>;
    /**
     * Handle one or more cases, object-style.
     * @param variations
     */
    with<Variations extends Splay<ComplementaryHandler<T, K, H>>>(variations: Limited<Variations, T[K]> & Variations): Matcher<T, K, H & Variations>;
    /**
     * Handle one or more cases with a set of types and a handler.
     * @param variations
     * @param handler
     */
    when<Variation extends T[K] | VariantCreator<T[K], Func, K>, Handler extends (x: Extract<T, Record<K, TypeStr<Variation, K>>>) => any>(variations: Variation | Variation[], handler: Handler): Matcher<T, K, H & Record<TypeStr<Variation, K>, Handler>>;
    /**
     * Handle one or more cases, object-style.
     * @deprecated - use with
     * @param variations
     */
    when<Variations extends Splay<Handler<T, K>>>(variations: Limited<Variations, T[K]> & Variations): Matcher<T, K, H & Variations>;
}
export interface MatcherFunc<K extends string> {
    /**
     * Create a matcher on some target variant instance.
     * @param target
     */
    matcher<T extends (TType extends TType ? Record<K, TType> : never), TType extends string>(target: T | TType): Matcher<T, K, {}>;
}
export declare function matcherImpl<K extends string>(key: K): MatcherFunc<K>;
export {};
//# sourceMappingURL=matcher.d.ts.map