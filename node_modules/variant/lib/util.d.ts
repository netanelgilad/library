import { Func, VariantCreator } from './precepts';
/**
 * Collapse a complex type into a more easily read object.
 */
export declare type Identity<T> = T extends object ? {} & {
    [P in keyof T]: T[P];
} : T;
/**
 * https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
 */
export declare type IsNever<T> = [T] extends [never] ? true : false;
/**
 * Identity function. Doubles as the noop func.
 * @param x
 */
export declare const identityFunc: <T>(x?: T) => T extends unknown ? {} : T;
/**
 * Determine whether or not a variable is a promise.
 * @param x potential promise.
 */
export declare function isPromise<T>(x: T | PromiseLike<T>): x is PromiseLike<T>;
/**
 * Extract a type string from either a string or `VariantCreator`
 */
export declare type TypeStr<T extends (string | VariantCreator<string, Func, K>), K extends string = 'type'> = T extends VariantCreator<infer R, Func, K> ? R : T extends string ? T : never;
/**
 * **H**igher-**O**rder **I**dentity.
 *
 * A higher order factory for this very useful wrapper function.
 *
 * ```ts
 * // Enforce the type constraint *and* narrow the return type.
 * function defineThing<T extends Template>(definition: T): T {
 *     return definition;
 * }
 * ```
 *
 * The above `defineThing` can now be generated through
 *
 * ```ts
 * const defineThing = HOI<Template>();
 * ```
 *
 * Or in more advanced to define something like a catalog:
 *
 * ```ts
 * const defineThings = HOI<Record<string, Template>>();
 * ```
 */
export declare const HOI: <Constraint>() => <T extends Constraint>(definition: T) => T;
//# sourceMappingURL=util.d.ts.map