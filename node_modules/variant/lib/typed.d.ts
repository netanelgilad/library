/**
 * Helper to retrieve the fields of a variation.
 */
export declare type VariationFields<T, TType extends string, K extends string> = Omit<Extract<T, Record<K, TType>>, K>;
/**
 * Enforce the expectation of a module that meets the contract.
 */
export declare type ExactDefinition<T extends Record<K, string>, K extends string> = {
    [P in T[K]]: (input: VariationFields<T, P, K>) => VariationFields<T, P, K>;
};
declare type VoidEmpty<T> = {
    [P in keyof T]: T[P] extends (...args: infer TArgs) => infer TReturn ? (...args: {} extends TArgs[0] ? [] : TArgs) => TReturn : T[P];
};
/**
 * A helper function for variantModule.
 *
 * This is the identity function by a better name.
 * @param x
 */
export declare const pass: <T>(x: T) => T;
export interface TypedFunc<K extends string> {
    /**
     * Enforce a variant following a pre-defined type.
     *
     * @param variant implementation of the underlying functions.
     * @returns the implementation passed in.
     *
     * @example
     * ```
     * type Option =
     *     | Variant<'Some', {payload: any}>
     *     | Variant<'None'>
     * ;
     * const Option = variant(typed<Option>({
     *     Some: pass,
     *     None: pass,
     * }))
     * // `pass` is just the identity function. Any function `(input: T) => T` is valid.
     * ```
     */
    typed<T extends Record<K, string>>(variant: ExactDefinition<T, K>): VoidEmpty<ExactDefinition<T, K>>;
    /**
     * Enforce a variant following a pre-defined type.
     *
     * Receive the `pass` function as a parameter.
     * @param factory factory function implementation of the underlying functions. Receives `pass` as the only parameter.
     * @returns the implementation passed in.
     *
     * @example
     * ```
     * type Option =
     *     | Variant<'Some', {payload: any}>
     *     | Variant<'None'>
     * ;
     * const Option = variant(typed<Option>(_ => ({
     *     Some: _,
     *     None: _,
     * })));
     * // `_` is just the identity function. Any function `(input: T) => T` is valid.
     * ```
     */
    typed<T extends Record<K, string>>(factory: (_: typeof pass) => ExactDefinition<T, K>): VoidEmpty<ExactDefinition<T, K>>;
}
export declare function typedImpl<K extends string>(_key: K): TypedFunc<K>;
export {};
//# sourceMappingURL=typed.d.ts.map