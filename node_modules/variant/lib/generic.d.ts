import { Func, TypesOf, Outputs, PatchObjectOrPromise, RawVariant, Stringable, TypeNames, VariantOf } from './precepts';
declare type primitive = number | string | symbol | boolean | bigint;
declare const GENERIC_BRAND: unique symbol;
/**
 * Announce to the world (specifically `variant`/`variantModule`) that
 */
export declare type GenericTemplate<T extends RawVariant> = T & {
    [GENERIC_BRAND]: undefined;
};
/**
 * Define a generic variant
 * @param func a template factory. Receives 26 generic placeholders (A-Z) in an object, returns a variant template
 * @returns A variant with generic creators
 */
export declare function onTerms<T extends RawVariant>(func: (alpha: Alpha) => T): GenericTemplate<T>;
declare const GTERM = "__term";
/**
 * A placeholder type representing a generic parameter.
 */
export interface GenericTerm<Label extends string> {
    [GTERM]: Label;
}
/**
 * Generic equivalent of `VariantCreator`
 *
 * Miraculously, by holding the pre-`Generify`'d functions as a type
 * parameter, we can actually inspect and extract those types for
 * `GVariantOf`. This is what allows the interface without the __Name object.
 */
export declare type GenericVariantCreator<Type extends string, F extends (...args: any[]) => {} = () => {}, K extends string = 'type'> = (<T>(...args: Generify<Parameters<F>, {
    [gp: string]: T;
}>) => Generify<PatchObjectOrPromise<ReturnType<F>, Record<K, Type>>, {
    [gp: string]: T;
}>) & Outputs<K, Type> & Stringable<Type>;
/**
 * Generic equivalent of `VariantTypeSpread`.
 *
 * Mapped type of keys to the variant creator's return type.
 */
export declare type GenericVariantTypeSpread<VM extends GenericVariantRecord<{}, string>> = {
    [P in keyof VM]: VM[P] extends GenericVariantCreator<infer Type, infer Creator, infer K> ? PatchObjectOrPromise<ReturnType<Creator>, Record<K, Type>> : never;
};
/**
 * Generic Variant Of.
 */
export declare type GVariantOf<VM extends GenericVariantRecord<{}, string>, TType extends TypeNames<VM>, Map extends {
    [gp: string]: any;
}> = TType extends keyof VM ? Generify<GenericVariantTypeSpread<VM>[TType], Map> : Generify<GenericVariantTypeSpread<VM>[keyof VM], Map>;
/**
 * The money.
 */
export declare type GenericVariantRecord<VM extends RawVariant, K extends string> = {
    [P in keyof VM]: GenericVariantCreator<(P & string), VM[P] extends Func ? VM[P] : () => {}, K>;
};
declare const GP: {
    A: import("./precepts").VariantCreator<"A", () => {}, "__term">;
    B: import("./precepts").VariantCreator<"B", () => {}, "__term">;
    C: import("./precepts").VariantCreator<"C", () => {}, "__term">;
    D: import("./precepts").VariantCreator<"D", () => {}, "__term">;
    E: import("./precepts").VariantCreator<"E", () => {}, "__term">;
    F: import("./precepts").VariantCreator<"F", () => {}, "__term">;
    G: import("./precepts").VariantCreator<"G", () => {}, "__term">;
    H: import("./precepts").VariantCreator<"H", () => {}, "__term">;
    I: import("./precepts").VariantCreator<"I", () => {}, "__term">;
    J: import("./precepts").VariantCreator<"J", () => {}, "__term">;
    K: import("./precepts").VariantCreator<"K", () => {}, "__term">;
    L: import("./precepts").VariantCreator<"L", () => {}, "__term">;
    M: import("./precepts").VariantCreator<"M", () => {}, "__term">;
    N: import("./precepts").VariantCreator<"N", () => {}, "__term">;
    O: import("./precepts").VariantCreator<"O", () => {}, "__term">;
    P: import("./precepts").VariantCreator<"P", () => {}, "__term">;
    Q: import("./precepts").VariantCreator<"Q", () => {}, "__term">;
    R: import("./precepts").VariantCreator<"R", () => {}, "__term">;
    S: import("./precepts").VariantCreator<"S", () => {}, "__term">;
    T: import("./precepts").VariantCreator<"T", () => {}, "__term">;
    U: import("./precepts").VariantCreator<"U", () => {}, "__term">;
    V: import("./precepts").VariantCreator<"V", () => {}, "__term">;
    W: import("./precepts").VariantCreator<"W", () => {}, "__term">;
    X: import("./precepts").VariantCreator<"X", () => {}, "__term">;
    Y: import("./precepts").VariantCreator<"Y", () => {}, "__term">;
    Z: import("./precepts").VariantCreator<"Z", () => {}, "__term">;
};
export declare type GP<T extends TypeNames<typeof GP> = undefined> = VariantOf<typeof GP, T>;
/**
 * Object with placeholders for generic terms.
 */
export declare const Alpha: {
    A: {
        __term: "A";
    };
    B: {
        __term: "B";
    };
    C: {
        __term: "C";
    };
    D: {
        __term: "D";
    };
    E: {
        __term: "E";
    };
    F: {
        __term: "F";
    };
    G: {
        __term: "G";
    };
    H: {
        __term: "H";
    };
    I: {
        __term: "I";
    };
    J: {
        __term: "J";
    };
    K: {
        __term: "K";
    };
    L: {
        __term: "L";
    };
    M: {
        __term: "M";
    };
    N: {
        __term: "N";
    };
    O: {
        __term: "O";
    };
    P: {
        __term: "P";
    };
    Q: {
        __term: "Q";
    };
    R: {
        __term: "R";
    };
    S: {
        __term: "S";
    };
    T: {
        __term: "T";
    };
    U: {
        __term: "U";
    };
    V: {
        __term: "V";
    };
    W: {
        __term: "W";
    };
    X: {
        __term: "X";
    };
    Y: {
        __term: "Y";
    };
    Z: {
        __term: "Z";
    };
};
/**
 * Type with placeholders for generic terms.
 */
export declare type Alpha = {
    [P in TypesOf<typeof GP>]: GenericTerm<P>;
};
interface TermMap {
    [term: string]: any;
}
/**
 * Transform some type containing a `GenericTerm` into the concrete type from
 * the term map.
 */
export declare type Generify<T, Map extends TermMap> = T extends GenericTerm<infer Label> ? Map[Label] : T extends primitive ? T : T extends ReadonlyArray<any> ? {
    [P in keyof T]: Generify<T[P], Map>;
} : T extends (...args: infer Args) => infer Return ? (...args: Generify<Args, Map>) => Generify<Return, Map> : T extends object ? {
    [P in keyof T]: Generify<T[P], Map>;
} : T;
export {};
//# sourceMappingURL=generic.d.ts.map