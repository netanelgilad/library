import { LookupTableToHandler } from './matcher';
import { DEFAULT_KEY, Message, Func, VariantModule, VariantOf, VariantError } from './precepts';
/**
 * A set of functions meant to handle the variations of an object.
 */
export declare type Handler<T extends Record<K, string>, K extends string> = {
    [P in T[K]]: (instance: Extract<T, Record<K, P>>) => any;
};
declare type AdvertiseDefault<T> = T & {
    /**
     * Adding a `default` value will make make this a partial match,
     * disabling exhaustiveness checking.
     */
    default?: Message<'Use this option to make the handling optional.'>;
};
declare type WithDefault<T, DefaultTerm> = Partial<T> & {
    [DEFAULT_KEY]: (instance: DefaultTerm) => any;
};
export declare type LiteralToUnion<T extends string | number | symbol, K extends string> = {
    [P in T]: Record<K, P>;
}[T];
export declare type MatchFuncs<K extends string> = {
    match: MatchOverloads<K>;
    /**
     * Create a variant from a catalog or enum. In other words,
     * elevate a literal `A | B | C` to a type union `{type: A} | {type: B} | {type: C}`
     * @param instance
     */
    ofLiteral<T extends string | number | symbol>(instance: T): LiteralToUnion<T, K>;
    /**
     * Elevate a literal `A | B | C` to a type union `{type: A} | {type: B} | {type: C}`
     * @deprecated use `ofLiteral`
     * @param instance
     */
    onLiteral<T extends string | number | symbol>(instance: T): LiteralToUnion<T, K>;
    /**
     * Handle some cases, deal with the rest in a  well-typed function. If the discriminated union
     * is `A | B | C` and `A` has been handled, then the else function will understand it will receive
     * only `B | C`.
     * @param branches
     * @param elseFunc
     */
    otherwise<P extends Partial<Handler<T, K>>, T extends Record<K, string>, Else extends (remainder: Exclude<T, Record<K, keyof P>>) => any>(branches: P, elseFunc: Else): (input: T) => HandlerFromPartial<P & {
        default: Else;
    }, T[K]>;
    partial: PartialOverloads<K>;
    prematch: PrematchFunc<K>;
    /**
     * Resolve the match with a lookup table.
     * @param handler
     */
    lookup<H extends Record<T[K], any>, T extends Record<K, string>>(handler: H): (instance: T) => LookupTableToHandler<H>;
    /**
     * Resolve the match but account for edge cases.
     * @param handler
     * @param fallback
     */
    withFallback<T extends Record<K, string>, H extends Handler<T, K>, F extends (instance: T) => any>(handler: H, fallback: F): (input: T) => ExplicitHandler<H, F, T[K]>;
};
/**
 * When H is acting as the generic term and its constraint, the system doesn't understand what to expect.
 * If H is empty, it still satisfies its own contract.
 *
 * This requires us to inform TS of what the expected keys should be, giving it shape.
 */
declare type ExplicitHandler<H extends Record<Keys, Func>, F, Keys extends string> = {
    [K in Keys]: H[K];
} & {
    [DEFAULT_KEY]: F;
};
declare type HandlerFromPartial<H extends Record<'default', unknown>, Keys extends string> = {
    [K in Keys]: H extends Record<K, any> ? H[K] : H['default'];
};
export interface PartialOverloads<K extends string> {
    /**
     * Handle some cases, use **`default:`** to handle the remainder.
     */
    <H extends AdvertiseDefault<Handler<T, K>>, T extends Record<K, string>>(handler: H | ((t: T) => H)): (input: T) => H;
    /**
     * Handle some cases, use **`default:`** to handle the remainder (Active).
     */
    <H extends WithDefault<Handler<T, K>, T>, T extends Record<K, string>>(handler: H | ((t: T) => H)): (input: T) => HandlerFromPartial<H, T[K]>;
}
export interface MatchOverloads<K extends string> {
    /**
     * **(inline)** Match an instance of a variant or literal union against its possible cases.
     * @remarks
     * This point-free overload is intended for inline use, not pre-matching.
     *
     * @param handler a handler object. This type will be properly constrained when used inline.
     * @template T instance of a variant
     * @template H handler object
     */
    <T extends Record<K, TType>, H extends Handler<T, K>, TType extends string>(handler: EnforceHandler<H> | ((t: T) => H)): (instance: T | TType) => ReturnType<H[keyof H]>;
    /**
     * Match an instance of a variant or literal union against its possible cases.
     * @remarks
     * Supports exhaustiveness checking, partial matching, and literals.
     *
     * @param target the target instance
     * @param handler an object with a function corresponding to each case
     * @returns The result of the appropriate branch based on the instance type
     */
    <T extends Record<K, TType>, H extends Handler<T, K>, TType extends string>(target: T | TType, handler: H | ((t: T) => H)): ReturnType<H[T[K]]>;
}
/**
 * Ensure that the handler object is not empty.
 */
export declare type EnforceHandler<T> = {} extends T ? VariantError<['Handler cannot be empty', 'Are you sure you are using this inline?']> : T;
export interface PrematchFunc<K extends string> {
    /**
     * Match against a variant model
     *
     * @param variant an object containing variant creators.
     * @returns a function to handle an instance of that type.
     */
    <T extends VariantModule<K>>(variant: T): TypedCurriedMatchFunc<VariantOf<T>, K>;
    /**
     * Match against a variant by type
     *
     * @template T a discriminated union
     * @returns a function to handle an instance of that type.
     */
    <T extends Record<K, string>>(): TypedCurriedMatchFunc<T, K>;
}
/**
 * Curried match func set to a specific type from `prematch`.
 */
export interface TypedCurriedMatchFunc<T extends Record<K, string>, K extends string> {
    /**
     * Resolve the predefined matcher.
     */
    <H extends Handler<T, K>>(handler: H | ((t: T) => H)): (instance: T) => ReturnType<H[keyof H]>;
}
export declare function matchImpl<K extends string>(key: K): MatchFuncs<K>;
export {};
//# sourceMappingURL=match.d.ts.map