"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeMap = exports.typeCatalog = void 0;
/**
 * Create an a string enum-like object containing the type literals of a variant.
 * @param variant the definition of the variant in question.
 * @template T the variant template, an object containing variant creators.
 * @returns an object `{[T: string]: T}`
 * @tutorial
 * ```ts
 * const Animal = variant({...}); // cat, dog, snake
 *
 * const animalType = typeCatalog(Animal);
 * // animalType: {cat: 'cat', dog: 'dog', snake: 'snake'};
 * ```
 */
function typeCatalog(variant) {
    return Object.values(variant).reduce((result, vc) => {
        return Object.assign(Object.assign({}, result), { [vc.type]: vc.type });
    }, {});
}
exports.typeCatalog = typeCatalog;
/**
 * Create a mapping object containing the friendly names of a variant's forms
 * and the type literals they correspond to.
 * @param variant the definition of the variant in question.
 * @template T the variant template, an object containing variant creators.
 * @tutorial
 *
 * In the trivial case where each property label of a variant is exactly the
 * type it generates, this is equivalent to `typeCatalog`
 * ```ts
 * const Animal = variant({...}); // cat, dog, snake
 *
 * const animalType = typeMap(Animal);
 * // animalType: {cat: 'cat', dog: 'dog', snake: 'snake'};
 * ```
 * However, `typeMap` shines when differences come into play.
 * ```ts
 * const Animal = scopedVariant('@animal', {...}); // cat, dog, snake
 * const animalType = typeMap(Animal);
 * // animalType: {cat: '@animal/cat', dog: '@animal/dog', snake: '@animal/snake'};
 * ```
 */
function typeMap(variant) {
    return Object.keys(variant).reduce((result, key) => {
        return Object.assign(Object.assign({}, result), { [key]: variant[key].type });
    }, {});
}
exports.typeMap = typeMap;
//# sourceMappingURL=typeCatalog.js.map