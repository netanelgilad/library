import { MatchFuncs } from './match';
import { Func, TypesOf, VariantCreator, VariantModule, VariantOf } from './precepts';
import { VMFromVC } from './variant';
declare type IsFunctions<T extends VariantModule<K>, K extends string = 'type'> = {
    [P in keyof T]: <O extends Record<K, string>>(object: O | {} | null | undefined) => object is VariantOf<T, P>;
};
/**
 * A wrapper around a variant to allow more aesthetically pleasing interfaces
 * and variant-specific functionality.
 */
export interface Remote<T extends VariantModule<K>, K extends string = 'type'> {
    /**
     * The key of the discriminant (`type`, `tag`, `kind`, `__typename`).
     */
    readonly key: K;
    /**
     * A collection of user-defined type guards to enable syntax like `Animal.is.dog(_)`.
     */
    readonly is: IsFunctions<T, K>;
    /**
     * The variant definition, a collection of tag constructors.
     */
    readonly new: T;
    /**
     * The match function.
     */
    match: MatchFuncs<K>['match'];
}
export declare enum CompareResult {
    Lesser = -1,
    Equal = 0,
    Greater = 1
}
declare type CreativeSequenceInput<K extends string, Type extends string = string> = Type | VariantCreator<Type, Func, K>;
export declare type CreatorFromSeqInput<T extends CreativeSequenceInput<K>, K extends string> = T extends VariantCreator<string, Func, string> ? T : T extends string ? VariantCreator<T, () => {}, K> : never;
/**
 * A valid input to a sequence element.
 */
declare type SequenceInput<K extends string, Type extends string = string> = CreativeSequenceInput<K, Type> | Record<K, Type>;
/**
 * Extract the underlying type from some given valid `SequenceInput`
 */
declare type SequenceInputType<T extends SequenceInput<K>, K extends string> = T extends string ? T : T extends VariantCreator<string, Func, K> ? T['type'] : T extends Record<K, string> ? T[K] : never;
/**
 * Give a variant an order or **sequence**, like a numerical enum.
 */
export interface Sequence<T extends VariantModule<K>, O extends SequenceInput<K, TypesOf<T>>, K extends string, RT extends Pick<T, SequenceInputType<O, K>> = Pick<T, SequenceInputType<O, K>>> extends Remote<RT, K> {
    /**
     * Compare two elements to discover whether `a` is greater, equal,
     * or lesser than `b`.
     */
    compare: (a: SequenceInput<K, TypesOf<RT>>, b: SequenceInput<K, TypesOf<RT>>) => CompareResult;
    /**
     * Get the index of some type in the sequence.
     */
    index: (a: SequenceInput<K, TypesOf<RT>>) => number;
    /**
     * Get some element by index.
     * @returns a tag constructor.
     */
    get: (index: number) => T[keyof T];
    /**
     * The number of elements.
     */
    readonly length: number;
    /**
     * A list of types ordered as the sequence.
     */
    readonly types: TypesOf<T>[];
}
export interface RemoteFuncs<K extends string> {
    /**
     * Create a "remote control" for a variant.
     * @param variant
     */
    remote<T extends VariantModule<K>>(variant: T): Remote<T, K>;
    /**
     * Create a sequence based on a variant.
     * @param module the variant definition.
     * @param order the list of string literal types or variation creators.
     */
    sequence<T extends VariantModule<K>, O extends SequenceInput<K>>(module: T, order: O[]): Sequence<Pick<T, SequenceInputType<O, K>>, O, K>;
    /**
     * Create a sequenced variant.
     * @param order the list of literal types or variation creators. Also the variant definition a la `variantList`.
     */
    sequence<O extends CreativeSequenceInput<K>>(order: O[]): Sequence<VMFromVC<CreatorFromSeqInput<O, K>>, O, K>;
}
export declare function remoteImpl<K extends string>(key: K): RemoteFuncs<K>;
export {};
//# sourceMappingURL=remote.d.ts.map