"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matcherImpl = exports.Matcher = exports.tableToHandler = void 0;
const match_tools_1 = require("./match.tools");
const variant_1 = require("./variant");
/**
 * Utility func to create a handler from a lookup table.
 * @param table
 * @returns
 */
function tableToHandler(table) {
    return Object.keys(table).reduce((acc, cur) => {
        const key = cur;
        return Object.assign(Object.assign({}, acc), { [key]: match_tools_1.just(table[key]) });
    }, {});
}
exports.tableToHandler = tableToHandler;
/**
 * The matcher, a builder-pattern form of `match()`
 *
 * * Create a matcher `matcher(animal)`
 * * Define cases
 *     * `.when('cat', _ => _.name)`
 *     * `.when(Animal.cat, c => c.name)`
 *     * `.when(['cat', Animal.dog], cd => cd.name)`,
 *     * `.when({cat: c => c.name, dog: d => d.name})`
 *     * `.register({cat: 'purr', dog: 'woof'})` for constants.
 *
 * * Execute the matcher
 *     * `.complete()` brings exhaustiveness checking
 *     * `.execute()` immediately runs the matcher, whether or not all cases are handled.
 *     * `.else(_ => {...})` immediately runs the matcher, resolving unhandled cases with a function.
 */
class Matcher {
    /**
     * Create a new matcher from the target
     * @param target the
     * @param handler the initial handler. Use `{}` for standard functionality.
     * @param key the discriminant. Use `'type'` for standard functionality.
     */
    constructor(
    /**
     * The match target.
     */
    target, 
    /**
     * The discrimant used for the union `T`
     */
    key, 
    /**
     * The in-progress handler object.
     */
    handler) {
        this.target = target;
        this.key = key;
        this.handler = handler;
        this.complete = ((options) => {
            var _a, _b;
            if (this.target != undefined && this.target[this.key] in this.handler) {
                return (_b = (_a = this.handler)[this.target[this.key]]) === null || _b === void 0 ? void 0 : _b.call(_a, this.target);
            }
            else {
                if ((options === null || options === void 0 ? void 0 : options.withFallback) != undefined) {
                    return options.withFallback(this.target);
                }
            }
        });
    }
    /**
     * Immediately execute the matcher. Exhaustiveness is not guaranteed.
     *
     * This is a **terminal** and resolves the matcher.
     */
    execute() {
        const chosenHandler = this.handler[this.target[this.key]];
        return chosenHandler === null || chosenHandler === void 0 ? void 0 : chosenHandler(this.target);
    }
    /**
     * Handle all unhandled cases and immediately execute.
     *
     * > **Exhaust** â€” to consume entirely, _Merriam-Webster_
     *
     * This is a **terminal** and resolves the matcher.
     * @param remainingCases an object wiht a method to handle every remaining case.
     * @returns the result of executing the handler, given these final additions.
     */
    exhaust(remainingCases) {
        var _a;
        const combinedHandler = Object.assign(Object.assign({}, this.handler), remainingCases);
        return (_a = combinedHandler[this.target[this.key]]) === null || _a === void 0 ? void 0 : _a.call(combinedHandler, this.target);
    }
    /**
     * Resolve all remaining cases without executing the matcher.
     * @param remainingCases
     * @returns
     */
    remaining(remainingCases) {
        return new Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), remainingCases));
    }
    /**
     * Execute the match. If the target type has been explicitly handled, use that logic.
     * Otherwise use the function passed here.
     *
     * This is a **terminal** and resolves the matcher.
     * @param func
     * @returns
     */
    else(func) {
        var _a, _b;
        if (this.target[this.key] in this.handler) {
            return (_b = (_a = this.handler)[this.target[this.key]]) === null || _b === void 0 ? void 0 : _b.call(_a, this.target);
        }
        else {
            return func(this.target);
        }
    }
    /**
     * Register a series of options as a lookup table.
     *
     * ```ts
     * const getSound = (a: Animal) => matcher(a)
     *     .register({
     *         cat: 'purr',
     *         dog: 'woof',
     *         snake: 'hiss',
     *     })
     *     .complete()
     * ```
     * @param table
     * @returns
     */
    register(table) {
        const newHandler = Object.assign(Object.assign({}, this.handler), tableToHandler(table));
        return new Matcher(this.target, this.key, newHandler);
    }
    /**
     * Provide an exhaustive table of the unhandled options and look up which value
     * to use based on the instance.
     *
     * This is a **terminal** and resolves the matcher.
     *
     * ```ts
     * const getSound = (a: Animal) => matcher(a)
     *     .lookup({
     *         cat: 'purr',
     *         dog: 'woof',
     *         snake: 'hiss',
     *     })
     * ```
     * @param table
     * @returns
     */
    lookup(table) {
        var _a;
        const combinedHandler = Object.assign(Object.assign({}, this.handler), tableToHandler(table));
        return (_a = combinedHandler[this.target[this.key]]) === null || _a === void 0 ? void 0 : _a.call(combinedHandler, this.target);
    }
    /**
     * Handle one or more cases, object-style.
     * @param variations
     */
    with(variations) {
        return new Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), variations));
    }
    // actual implementation
    when(variations, handler) {
        if (handler != undefined) {
            // 2 param case
            const list = Array.isArray(variations) ? variations : [variations];
            const newCases = list.reduce((acc, cur) => {
                const type = typeof cur === 'string' ? cur : variant_1.isVariantCreator(cur) ? cur.type : undefined;
                return type != undefined ? (Object.assign(Object.assign({}, acc), { [type]: handler })) : (acc);
            }, {});
            return new Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), newCases));
        }
        else {
            //1 param case
            return new Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), variations));
        }
    }
}
exports.Matcher = Matcher;
function matcherImpl(key) {
    function matcher(target) {
        const actualTarget = typeof target === 'string'
            ? { [key]: target }
            : target;
        return new Matcher(actualTarget, key, {});
    }
    return { matcher };
}
exports.matcherImpl = matcherImpl;
//# sourceMappingURL=matcher.js.map