export declare const descope: <T extends Record<"type", `${string}/${string}`>>(target: T) => T extends Record<"type", `${string}/${infer TType}`> ? import("../util").Identity<Omit<T, "type"> & Record<"type", TType>> : T, flags: <T extends Record<"type", string>>(flags: T[]) => { [P in T["type"]]: Extract<T, Record<"type", P>>; }, inferTypes: <T extends Record<"type", string>>(instance: T) => { [P in T["type"]]: P; }, isOfVariant: {
    <T extends import("..").VariantModule<"type">>(instance: {} | null | undefined, variant: T): instance is import("../util").Identity<{ [P in keyof T]: import("../precepts").CreatorOutput<T[P]>; }[keyof T]>;
    <T_1 extends import("..").VariantModule<"type">>(variant: T_1): (instance: {} | null | undefined) => instance is import("../util").Identity<{ [P_1 in keyof T_1]: import("../precepts").CreatorOutput<T_1[P_1]>; }[keyof T_1]>;
}, isType: {
    <T extends string | import("../precepts").VariantCreator<string, import("../precepts").Func, "type">>(type: T): <O extends Record<"type", string>>(object: O) => object is Extract<O, Record<"type", import("../util").TypeStr<T, "type">>>;
    <O_1 extends Record<"type", string>, T_1 extends O_1["type"] | import("../precepts").VariantCreator<O_1["type"], import("../precepts").Func, "type">>(object: O_1 | null | undefined, type: T_1): object is Extract<O_1, Record<"type", import("../util").TypeStr<T_1, "type">>>;
}, match: import("../match").MatchOverloads<"type">, matcher: <T extends TType extends TType ? Record<"type", TType> : never, TType extends string>(target: T | TType) => import("../matcher").Matcher<T, "type", {}>, ofLiteral: <T extends string | number | symbol>(instance: T) => import("../match").LiteralToUnion<T, "type">, onLiteral: <T extends string | number | symbol>(instance: T) => import("../match").LiteralToUnion<T, "type">, otherwise: <P extends Partial<import("../match").Handler<T, "type">>, T extends Record<"type", string>, Else extends (remainder: Exclude<T, Record<"type", keyof P>>) => any>(branches: P, elseFunc: Else) => (input: T) => { [K in T["type"]]: P & {
    default: Else;
} extends Record<K, any> ? (Record<K, any> & P & {
    default: Else;
})[K] : (P & {
    default: Else;
})["default"]; }, partial: import("../match").PartialOverloads<"type">, prematch: import("../match").PrematchFunc<"type">, remote: <T extends import("..").VariantModule<"type">>(variant: T) => import("../remote").Remote<T, "type">, scoped: <T extends import("../precepts").RawVariant, Scope extends string>(scope: Scope, v: T) => { [P in keyof T & string]: import("../precepts").VariantCreator<`${Scope}/${P}`, T[P] extends undefined ? () => {} : T[P] extends import("../precepts").Func ? T[P] : T[P] extends object ? () => {} : T[P], "type">; }, sequence: {
    <T extends import("..").VariantModule<"type">, O extends Record<"type", string> | (string | import("../precepts").VariantCreator<string, import("../precepts").Func, "type">)>(module: T, order: O[]): import("../remote").Sequence<Pick<T, O extends string ? O : O extends import("../precepts").VariantCreator<string, import("../precepts").Func, "type"> ? O["type"] : O extends Record<"type", string> ? O["type"] : never>, O, "type", Pick<Pick<T, O extends string ? O : O extends import("../precepts").VariantCreator<string, import("../precepts").Func, "type"> ? O["type"] : O extends Record<"type", string> ? O["type"] : never>, O extends string ? O : O extends import("../precepts").VariantCreator<string, import("../precepts").Func, "type"> ? O["type"] : O extends Record<"type", string> ? O["type"] : never>>;
    <O_1 extends string | import("../precepts").VariantCreator<string, import("../precepts").Func, "type">>(order: O_1[]): import("../remote").Sequence<import("../variant").VMFromVC<import("../remote").CreatorFromSeqInput<O_1, "type">>, O_1, "type", Pick<import("../variant").VMFromVC<import("../remote").CreatorFromSeqInput<O_1, "type">>, O_1 extends string ? O_1 : O_1 extends import("../precepts").VariantCreator<string, import("../precepts").Func, "type"> ? O_1["type"] : O_1 extends Record<"type", string> ? O_1["type"] : never>>;
}, lookup: <H extends Record<T["type"], any>, T extends Record<"type", string>>(handler: H) => (instance: T) => import("../matcher").LookupTableToHandler<H>, typed: {
    <T extends Record<"type", string>>(variant: import("../typed").ExactDefinition<T, "type">): { [P in keyof import("../typed").ExactDefinition<T, "type">]: import("../typed").ExactDefinition<T, "type">[P] extends (...args: infer TArgs) => infer TReturn ? (...args: {} extends TArgs[0] ? [] : TArgs) => TReturn : import("../typed").ExactDefinition<T, "type">[P]; };
    <T_1 extends Record<"type", string>>(factory: (_: <T_2>(x: T_2) => T_2) => import("../typed").ExactDefinition<T_1, "type">): { [P_1 in keyof import("../typed").ExactDefinition<T_1, "type">]: import("../typed").ExactDefinition<T_1, "type">[P_1] extends (...args: infer TArgs) => infer TReturn ? (...args: {} extends TArgs[0] ? [] : TArgs) => TReturn : import("../typed").ExactDefinition<T_1, "type">[P_1]; };
}, types: {
    <T extends import("..").VariantModule<"type">>(content: T): import("../util").Identity<import("..").TypesOf<T>>[];
    <T_1 extends Record<"type", string>>(content: T_1[]): T_1["type"][];
}, variant: {
    <VM extends import("../precepts").RawVariant>(template: import("../generic").GenericTemplate<VM>): import("../util").Identity<import("../generic").GenericVariantRecord<VM, "type">>;
    <VM_1 extends import("../precepts").RawVariant>(template: VM_1): import("../util").Identity<import("../variant").VariantRecord<VM_1, "type">>;
    <T extends string | import("../precepts").VariantCreator<string, import("../precepts").Func, string>>(template: T[]): import("../util").Identity<import("../variant").VMFromVC<T extends import("../precepts").VariantCreator<string, import("../precepts").Func, string> ? T : T extends string ? import("../precepts").VariantCreator<T, () => {}, "type"> : never>>;
}, variantList: <T extends string | import("../precepts").VariantCreator<string, import("../precepts").Func, string>>(template: T[]) => import("../util").Identity<import("../variant").VMFromVC<T extends import("../precepts").VariantCreator<string, import("../precepts").Func, string> ? T : T extends string ? import("../precepts").VariantCreator<T, () => {}, "type"> : never>>, variantModule: <VM extends import("../precepts").RawVariant>(template: VM) => import("../util").Identity<import("../variant").VariantRecord<VM, "type">>, variation: <T extends string, F extends import("../precepts").Func = () => {}>(type: T, creator?: F | undefined) => import("../precepts").VariantCreator<T, F extends import("../precepts").VariantCreator<string, infer VF, "type"> ? VF : F, "type">, withFallback: <T extends Record<"type", string>, H extends import("../match").Handler<T, "type">, F extends (instance: T) => any>(handler: H, fallback: F) => (input: T) => { [K in T["type"]]: H[K]; } & {
    default: F;
};
//# sourceMappingURL=index.d.ts.map