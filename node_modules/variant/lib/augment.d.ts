import { Func, PatchObjectOrPromise, RawVariant, VariantCreator, VariantOf } from './precepts';
import { Identity } from './util';
import { VariantRecord } from './variant';
/**
 * Augment an existing variant model with new or overridden fields.
 *
 * @param variantDefinition a template for the variant, extends `RawVariant`, may be an existing variant.
 * @param f the augment function. This receives the object that is is augmenting, enabling calculated properties.
 * @tutorial
 * Use in conjunction with `variant` (or `variantModule`).
 *
 * ```typescript
 * // Add a timestamp to every action.
 * export const Action = variant(augment(
 *     {
 *         AddTodo: fields<{text: string, due?: number}>(),
 *         UpdateTodo: fields<{todoId: number, text?: string, due?: number, complete?: boolean}>(),
 *     },
 *     () => ({timestamp: Date.now()}),
 * ));
 * ```
 */
export declare function augment<T extends RawVariant, F extends (x: VariantOf<VariantRecord<T, string>>) => any>(variantDefinition: T, f: F): AugmentedRawVariant<T, F>;
declare type CleanResult<T, U> = T extends undefined ? U : T extends Func ? T : T extends object ? U : T;
declare type FullyFuncRawVariant<V extends RawVariant> = {
    [P in keyof V & string]: CleanResult<V[P], () => {}>;
};
declare type PatchFunc<F, O extends object> = F extends (...args: infer TArgs) => infer TReturn ? (...args: TArgs) => PatchObjectOrPromise<TReturn, O> : never;
/**
 * A variant patched with an extra property.
 */
export declare type AugmentedRawVariant<V extends RawVariant, F extends Func> = {
    [P in keyof V]: V[P] extends VariantCreator<infer VT, infer VCF, infer VK> ? VariantCreator<VT, PatchFunc<VCF, ReturnType<F>>, VK> : (...args: Parameters<FullyFuncRawVariant<V>[P & string]>) => Identity<ReturnType<F> & ReturnType<FullyFuncRawVariant<V>[P & string]>>;
};
export {};
//# sourceMappingURL=augment.d.ts.map