import { Func } from './precepts';
import { Identity } from './util';
/**
 * Constrained template.
 */
export declare type ConstrainedTemplate<F extends Func> = {
    [type: string]: (...args: [...Parameters<F>, ...any[]]) => ReturnType<F>;
};
/**
 * Patched Template helper.
 */
declare type PatchedTemplate<T extends ConstrainedTemplate<F>, F extends Func> = {
    [P in keyof T]: (...args: Parameters<T[P]>) => Identity<ReturnType<T[P]> & ReturnType<F>>;
};
/**
 * Constrained variant. A variant where each form abides by a given constraint - handles these
 * inputs and provides these outputs.
 *
 * This can be used to ensure optional properties exist on the union type.
 * @param _constraint_
 * @param v
 * @returns
 */
export declare function constrained<T extends ConstrainedTemplate<F>, F extends Func>(_constraint_: F, v: T): PatchedTemplate<T, F>;
export {};
//# sourceMappingURL=constrained.d.ts.map