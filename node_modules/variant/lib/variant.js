"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.variantImpl = exports.isVariantCreator = exports.scopeType = void 0;
const util_1 = require("./util");
/**
 * Internal function to consistently generate a scoped type.
 * @param scope
 * @param type
 * @returns
 */
const scopeType = (scope, type) => `${scope}/${type}`;
exports.scopeType = scopeType;
function descopeType(s) {
    var _a;
    return ((_a = s.split('/')[1]) !== null && _a !== void 0 ? _a : s);
}
const VARIANT_CREATOR_BRAND = Symbol('Variant Creator');
function isVariantCreator(func) {
    return VARIANT_CREATOR_BRAND in func;
}
exports.isVariantCreator = isVariantCreator;
function variantImpl(key) {
    function scope(scope, v) {
        return Object.keys(v).reduce((acc, key) => {
            return Object.assign(Object.assign({}, acc), { [key]: variation(exports.scopeType(scope, key), typeof v[key] === 'function' ? v[key] : util_1.identityFunc) });
        }, {});
    }
    function descope(obj) {
        return Object.assign(Object.assign({}, obj), { [key]: descopeType(obj[key]) });
    }
    function variation(type, creator) {
        let maker = (...args) => {
            const returned = (creator !== null && creator !== void 0 ? creator : util_1.identityFunc)(...args);
            if (util_1.isPromise(returned)) {
                return returned.then(result => {
                    if (key in (result !== null && result !== void 0 ? result : {})) {
                        return result;
                    }
                    else {
                        return Object.assign(result !== null && result !== void 0 ? result : {}, { [key]: type });
                    }
                });
            }
            else {
                if (key in (returned !== null && returned !== void 0 ? returned : {})) {
                    return returned;
                }
                else {
                    return Object.assign(returned !== null && returned !== void 0 ? returned : {}, { [key]: type });
                }
            }
        };
        Object.defineProperty(maker, 'name', { value: type, writable: false });
        const outputs = { key, type };
        return Object.assign(maker, outputs, {
            [VARIANT_CREATOR_BRAND]: VARIANT_CREATOR_BRAND,
            toString: function () { return this.type; }
        });
    }
    function variantModule(template) {
        return Object.entries(template).reduce((result, [vmKey, vmVal]) => {
            // whether to use the existing value (pass-through variations), or create a new variation.
            const creator = typeof vmVal === 'function'
                ? isVariantCreator(vmVal)
                    ? vmVal
                    : variation(vmKey, vmVal)
                : variation(vmKey, util_1.identityFunc);
            return Object.assign(Object.assign({}, result), { [vmKey]: creator });
        }, {});
    }
    function variantList(template) {
        return template.map((t) => {
            if (typeof t === 'string') {
                return variation(t);
            }
            else if (typeof t === 'function') {
                return t;
            }
            return t;
        }).reduce((result, t) => {
            let creator = ((typeof t === 'string') ? variation(t) : t);
            return Object.assign(Object.assign({}, result), { [creator.type]: creator });
        }, {});
    }
    function variant(template) {
        if (Array.isArray(template)) {
            return variantList(template);
        }
        else {
            return variantModule(template);
        }
    }
    return { descope, scoped: scope, variant, variantList, variantModule, variation };
}
exports.variantImpl = variantImpl;
//# sourceMappingURL=variant.js.map