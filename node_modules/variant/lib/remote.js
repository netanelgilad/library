"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remoteImpl = exports.CompareResult = void 0;
const isType_1 = require("./isType");
const match_1 = require("./match");
const variant_1 = require("./variant");
var CompareResult;
(function (CompareResult) {
    CompareResult[CompareResult["Lesser"] = -1] = "Lesser";
    CompareResult[CompareResult["Equal"] = 0] = "Equal";
    CompareResult[CompareResult["Greater"] = 1] = "Greater";
})(CompareResult = exports.CompareResult || (exports.CompareResult = {}));
function remoteImpl(key) {
    const { isType } = isType_1.isTypeImpl(key);
    const { match } = match_1.matchImpl(key);
    const { variantList } = variant_1.variantImpl(key);
    function isFunctions(vmod) {
        const keys = Object.keys(vmod);
        return keys.reduce((acc, key) => {
            return Object.assign(Object.assign({}, acc), { [key]: isType(key) });
        }, {});
    }
    function remote(vmod) {
        return {
            key,
            is: isFunctions(vmod),
            new: vmod,
            match,
        };
    }
    ;
    function getType(input) {
        if (typeof input === 'string') {
            return input;
        }
        else if (typeof input === 'function') {
            return input.type;
        }
        else {
            return input[key];
        }
    }
    function _sequence(module, order) {
        const miniModule = module;
        const result = remote(miniModule);
        const keyOrder = order.map(getType);
        return Object.assign(Object.assign({}, result), { length: order.length, compare: (a, b) => {
                const ai = keyOrder.findIndex(i => i === getType(a));
                const bi = keyOrder.findIndex(i => i === getType(b));
                const diff = ai - bi;
                return diff === 0 ? diff : (diff / Math.abs(diff));
            }, get(i) {
                const type = this.types[i];
                return this.new[type];
            }, index: a => keyOrder.findIndex(i => i === getType(a)), types: keyOrder });
    }
    function _sequenceOfList(order) {
        const module = variantList(order);
        return _sequence(module, order);
    }
    function sequence(module, order) {
        if (Array.isArray(module)) {
            return _sequenceOfList(module);
        }
        else {
            return _sequence(module, order);
        }
    }
    return { remote, sequence };
}
exports.remoteImpl = remoteImpl;
//# sourceMappingURL=remote.js.map